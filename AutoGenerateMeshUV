
using System.IO;
using System;
using UnityEngine;
using UnityEditor;

namespace ArtTools
{
    public class RadarMeshEditor
    {
        public static string resPath = "Assets/ArtRes/RadarMesh/";
        public static string atlasName = "item";
        public static float quadWidth = 2.0f;
        public static float quadHeight = 2.0f;

        //获取所有sprites
        //创建相应数量mesh
        //修改UV并保存
        [MenuItem("美术资源处理/生成雷达meshUV")]
        static void GenerateMeshUV()
        {
            var sprites = Resources.LoadAll<Sprite>(atlasName);
            var textureRect = new Rect(0, 0, sprites[0].texture.width, sprites[0].texture.height);

            Debug.Assert(sprites != null, "Cant Find Radar Atlas!!!");
            if(!Directory.Exists(resPath))
            {
                Directory.CreateDirectory(resPath);
            }
            else
            {
                var files = Directory.GetFiles(resPath);
                for(int i = 0; i < files.Length; i++)
                {
                    File.Delete(files[i]);
                }
                Directory.Delete(resPath);
                Directory.CreateDirectory(resPath);
            }

            for (int i = 0; i < sprites.Length; i++)
            {
                //Create Mesh
                var mesh = new Mesh();

                var vertices = new Vector3[4];

                vertices[0] = new Vector3(0, 0, 0);
                vertices[1] = new Vector3(quadWidth, 0, 0);
                vertices[2] = new Vector3(0, quadHeight, 0);
                vertices[3] = new Vector3(quadWidth, quadHeight, 0);

                mesh.vertices = vertices;

                var tri = new int[6];

                tri[0] = 0;
                tri[1] = 2;
                tri[2] = 1;

                tri[3] = 2;
                tri[4] = 3;
                tri[5] = 1;

                mesh.triangles = tri;

                var normals = new Vector3[4];

                normals[0] = -Vector3.forward;
                normals[1] = -Vector3.forward;
                normals[2] = -Vector3.forward;
                normals[3] = -Vector3.forward;

                mesh.normals = normals;

                var uv = new Vector2[4];

                uv[0] = new Vector2(0, 0);
                uv[1] = new Vector2(1, 0);
                uv[2] = new Vector2(0, 1);
                uv[3] = new Vector2(1, 1);

                mesh.uv = uv;
                ////SetUV
                var rect = sprites[i].rect;
                var tempUV = new Vector4(rect.x / textureRect.width,
                        rect.y / textureRect.height, rect.width / textureRect.width, rect.height / textureRect.height);
                setTile(mesh, tempUV.z, tempUV.w);
                setOffset(mesh, tempUV.x, tempUV.y);
                AssetDatabase.CreateAsset(mesh, resPath + sprites[i].name + ".asset");
            }
            AssetDatabase.SaveAssets();
        }

        private static void setTile(Mesh mesh, float x, float y)
        {
            Vector2[] uvs = new Vector2[mesh.vertices.Length];
            for (var i = 0; i < uvs.Length; i++)
            {
                uvs[i].x = mesh.uv[i].x * x;
                uvs[i].y = mesh.uv[i].y * y;
            }
            mesh.uv = uvs;
        }

        private static void setOffset(Mesh mesh, float x, float y)
        {
            Vector2[] uvs = new Vector2[mesh.vertices.Length];
            for (var i = 0; i < uvs.Length; i++)
            {
                uvs[i].x = mesh.uv[i].x + x;
                uvs[i].y = mesh.uv[i].y + y;

                /*(isRotated) {
                    if(!TPVars.isFreeVersion) {
                        Quaternion rot = Quaternion.Euler(0 ,0, -90);
                        uvs[i] = rot * uvs[i];
                    } else {
                        Debug.LogWarning("Texture Rotation is not supported by free version");
                    }

                }*/

            }

            mesh.uv = uvs;
        }
    }
}
```
